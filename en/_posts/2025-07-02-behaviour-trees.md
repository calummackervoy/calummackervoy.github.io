---

title: Game AI Designed to Surprise
summary: Collaborative Behaviour Trees in a Games Commons
lang: en
lang-ref: commons-behaviour-trees

header_image: '/assets/img/post_headers/03.jpg'
---

The Commons is property that opens itself up to use by anyone, and which is owned and managed by the people who use it... So what would that mean when talking about AI in game development?

For the past couple of years I've been working on the concept of a [Games Commons](https://gamescommons.com/), which is a new way of designing games that centres around flexibility, collaboration and the concept of Do-It-Together. These are games built around a creative community of hackers, like Wikipedia but for game content.

Our flagship game is about making and breaking social systems. In-game, social systems are made up of networked agents that are running AI scripts built by players, shared in common and quality-reviewed by communities. The design of the tools which enable the player to create and collaborate on such scripts is the subject of today's article.

<img src="{{ '/assets/img/post_assets/behaviour-trees/simpolis-bt-interface.png' | absolute_url }}" class="blog-centred-image" alt="The Heads Up Display of Sim Polis, showing the portrait of a humanoid Fox and a number of tabs for the basic information, inventory and behaviours of the Fox. The selected tab shows a grid with a number of branching nodes, the AI behaviour script for the character" />
<p class="image-caption">The interface is very much a work-in-progress.</p>

Agents need an AI script for decision making; put simply it tells them what to do next. We sometimes assume AI in games is strategic: the agent could be a peer of the human player, working with or against them. At the other extreme, though, the agent may be there simply to decorate the world and make it believable, appearing to interact with items in the neighbourhood just so that a town looks lived in as the player passes by. Usually a single game will employ several different kinds of AI, each serving different purposes. "Good game AI" is therefore not necessarily AI which is strategic or adaptive enough to pass the Turing test; it's AI which is appropriate to the objectives of the game designer for the agent that is deploying it.

The design of Sim Polis revolves around flexible systems that are evolving with player interaction, and the AI as such needs to be adaptable to the "open world assumption" (meaning, anything is possible.) It's not enough to have an apple merchant show up in the town square every morning expecting to sell his apples, if due to player interaction apples are now widely believed to be poisonous by the townspeople or the town square has been overrun by zombies. Better than not showing up at all, the apple merchant _should_ show up in the town square, they should realise that something is wrong and then they should start to panic. Flexibility like this is challenging enough, but we also need a structure accessible enough that players can create and share these this scripts themselves via the interface. Thankfully both of these vectors favour a _modular_ approach to AI: when the apple merchant needs to panic, they can discover a "panic module", which they can be designed and executed in relative isolation to everyday merchant behaviour.

The perfect structure for this is also fairly common in game design. **Behaviour Trees** are essentially flowcharts that direct the decisions to be made and the actions taken by an agent. A simple behaviour tree might instruct an agent to eat if it is hungry:

<img src="{{ '/assets/img/post_assets/behaviour-trees/behaviour_tree_example.png' | absolute_url }}" class="blog-centred-image" alt="A flowchart displays a control node, 'hungry?'. One branch (yes) feeds into the action node, 'eat'. A second branch (no) feeds into another control node, labelled '...' to illustrate that in this case the tree continues" />

The tree here begins with the **control** node "is the agent hungry?". If the agent is hungry, it would execute the action node: "eat something". If the agent is not hungry, it would follow the other side of the tree. The result is that hunger is prioritised. If the agent is not hungry, then the flow continues. We can imagine a situation where (relieved of hunger) the agent is free to subsequently pursue a more whimsical chain of behaviours:

<img src="{{ '/assets/img/post_assets/behaviour-trees/wander_shout.png' | absolute_url }}" class="blog-full-image" alt="In a second example, the flowchart leads through two action nodes; wander and shout. These nodes are followed by a new type of node, a mutate node, which is labelled 'destroy branch'. Finally we have a control node signifying that the tree continues">

In the example above the agent will wander, and then shout. This branch of the tree finishes with a **forget** node, a special kind of control node for permanently modifying the behaviour tree itself. Execution of this node will destroy the wander-shout sub-branch, since the behaviour should be executed once - it was intended to be whimsical; a moment of madness. It also demonstrates that behaviour trees are _modular_; we can imagine the wander-shout branch being sufficient to define the entire behaviour tree of a _raving lunatic_, but for another agent we could plug in the same branch as just one aspect of their behaviour:

<img src="{{ '/assets/img/post_assets/behaviour-trees/learning.png' | absolute_url }}" class="blog-full-image" alt="In this example both previous examples are pulled together. There is a condition, 'drunk?' which triggers the wander, shout and forget nodes, rendered smaller to indicate that they are a module that has been imported. This branch leads into a new behaviour, labelled 'learn'. If the agent is not drunk then the chart flows into the hunger tree from the first example, also imported">

If the agent is drunk, they wander, shout and forget, before executing a new node, "learn". If the player is not drunk, the chart moves on to the hunger condition from the first example. We can see here how the behaviours wander-shout-forget, and hunger-eat, have been packaged into branches. Once packaged, they can be re-used by their creator in the behaviour trees of different agents, and published online with some metadata about what the branch does. Once published online other players can import the behaviour into their own agents, which is already a powerful mechanism for building a games commons. Further from this we have the "learn" node, which with the right metadata, can use search parameters for the agent to discover a new drunken behaviour online from the games commons. The next time this tree executes and the agent is still drunk, he will have forgotten the wander-shout behaviour but may discover a behaviour someone has published on the games commons that causes him to fall over and begin singing.

The fact that the nodes on our behaviour trees are driven by data that can be published and then discovered _at run time_ allows for the emergence of spontaneous and unique behaviour that isn't conceivable in traditional game design. We can imagine a situation where our player's agent, hitherto a hunter and a cave man, has a moment of inspiration which allows them to learn the carving of bones into religious statues, and after hunting they begin to perform increasingly elaborate religious ceremonies. We quickly begin to see the flexibility of the behaviour tree system, but this also provides a powerful illustration of what is a _Games Commons_: another player lovingly created the process of tribalistic religious ceremonies, and in the publishing opened the possibility of everyone in the community to discover and experience them. The game evolves, driven by the creativity of its player base.
